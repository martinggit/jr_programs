/* This JR file was generated by m2jr */
/* for the signal and wait signaling discipline */


// Despachador.m, line 1: _monitor Despachador {

class Despachador {
  sem m_mutex = 1;
  sem m_urgentq = 0;
  int m_n_urgentq = 0;
  String m_name;
  public Despachador(String n) {
    this.m_name = n;
  }
  private void m_next() {
      if (m_n_urgentq > 0) {
        m_n_urgentq--;
        V(m_urgentq);
      }
      else {
        V(m_mutex);
      }
  }

// Despachador.m, line 2:   


// Despachador.m, line 3:   _var boolean cpu0Libre = true;

private boolean
cpu0Libre
=true
;
// Despachador.m, line 4:   _var boolean cpu1Libre = true;

private boolean
cpu1Libre
=true
;
// Despachador.m, line 5:   _var int asignacionesCPU0 = 0;

private int
asignacionesCPU0
=0;
// Despachador.m, line 6:   _var int asignacionesCPU1 = 0;

private int
asignacionesCPU1
=0;
// Despachador.m, line 7: 


// Despachador.m, line 8:   _condvar esperaCPU;


// Despachador.m, line 9: 


// Despachador.m, line 10:   _proc int adquirirCPU(int pid) {

private m_condvar esperaCPU = new m_condvar("esperaCPU");
public
int
adquirirCPU
(int
pid
){
    op void m_return_from_wait();
    P(m_mutex);

// Despachador.m, line 11:     while (!cpu0Libre && !cpu1Libre) {//mientras no haya ningun CPU libre espero

while
(!cpu0Libre
&&!cpu1Libre
){
// Despachador.m, line 12:       _wait(esperaCPU);

{  m_condvar m_cv = (esperaCPU );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
}
// Despachador.m, line 13:     }


// Despachador.m, line 14: 


// Despachador.m, line 15:     if (cpu0Libre) {

}if
(cpu0Libre
){
// Despachador.m, line 16:       cpu0Libre = false;

cpu0Libre
=false
;
// Despachador.m, line 17:       asignacionesCPU0++;

asignacionesCPU0
++;
// Despachador.m, line 18:       System.out.println("Proceso " + pid + " asignado a CPU0");

System
.out
.println
("Proceso "+pid
+" asignado a CPU0");
// Despachador.m, line 19:       _return 0;

{ if (true) {
  m_next();
  return 
0
// Despachador.m, line 20:     } else {

;
}}
}else
{
// Despachador.m, line 21:       cpu1Libre = false;

cpu1Libre
=false
;
// Despachador.m, line 22:       asignacionesCPU1++;

asignacionesCPU1
++;
// Despachador.m, line 23:       System.out.println("Proceso " + pid + " asignado a CPU1");

System
.out
.println
("Proceso "+pid
+" asignado a CPU1");
// Despachador.m, line 24:       _return 1;

{ if (true) {
  m_next();
  return 
1
// Despachador.m, line 25:     }

;
}}

// Despachador.m, line 26:   }

}
// Despachador.m, line 27: 


// Despachador.m, line 28:   _proc void liberarCPU(int cpu) {

  m_next();
throw new RuntimeException("reached end of non-void _proc (Despachador.m, line 28) without executing a return");
}
public
void
liberarCPU
(int
cpu
){
    op void m_return_from_wait();
    P(m_mutex);

// Despachador.m, line 29:     if (cpu == 0) {

if
(cpu
==0){
// Despachador.m, line 30:       cpu0Libre = true;

cpu0Libre
=true
;
// Despachador.m, line 31:       System.out.println("CPU0 liberada");

System
.out
.println
("CPU0 liberada");
// Despachador.m, line 32:     } else {

}else
{
// Despachador.m, line 33:       cpu1Libre = true;

cpu1Libre
=true
;
// Despachador.m, line 34:       System.out.println("CPU1 liberada");

System
.out
.println
("CPU1 liberada");
// Despachador.m, line 35:     }


// Despachador.m, line 36:     _signal(esperaCPU);

}{ if ((esperaCPU ).m_signal()) {
  P(m_mutex);
}}

// Despachador.m, line 37:   }


// Despachador.m, line 38: 


// Despachador.m, line 39:   _proc void mostrarEstadisticas() {

  m_next();
}
public
void
mostrarEstadisticas
(){
    op void m_return_from_wait();
    P(m_mutex);

// Despachador.m, line 40:     System.out.println("Asignaciones CPU0: " + asignacionesCPU0);

System
.out
.println
("Asignaciones CPU0: "+asignacionesCPU0
);
// Despachador.m, line 41:     System.out.println("Asignaciones CPU1: " + asignacionesCPU1);

System
.out
.println
("Asignaciones CPU1: "+asignacionesCPU1
);
// Despachador.m, line 42:   }


// Despachador.m, line 43: }

  m_next();
}
}
