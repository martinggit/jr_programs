/* This JR file was generated by m2jr */
/* for the signal and continue signaling discipline */


// BoundedBuffer.m, line 1: _monitor BoundedBuffer {

class BoundedBuffer {
  sem m_mutex = 1;
  sem m_urgentq = 0;
  int m_n_urgentq = 0;
  String m_name;
  public BoundedBuffer(String n) {
    this.m_name = n;
  }
  private void m_next() {
      if (m_n_urgentq > 0) {
        m_n_urgentq--;
        V(m_urgentq);
      }
      else {
        V(m_mutex);
      }
  }

// BoundedBuffer.m, line 2:     private static final int N = 5; //Size of the buffer

private
static
final
int
N
=5;
// BoundedBuffer.m, line 3: 


// BoundedBuffer.m, line 4:     _var String[] buffer = new String[N];

private String
[]buffer
=new
String
[N
];
// BoundedBuffer.m, line 5:     _var int front;

private int
front
;
// BoundedBuffer.m, line 6:     _var int rear;

private int
rear
;
// BoundedBuffer.m, line 7:     _var int count;

private int
count
;
// BoundedBuffer.m, line 8: 


// BoundedBuffer.m, line 9:     _condvar notFull;


// BoundedBuffer.m, line 10:     _condvar notEmpty;  

private m_condvar notFull = new m_condvar("notFull");

// BoundedBuffer.m, line 11: 


// BoundedBuffer.m, line 12:     _proc void deposit(String data){ //proc es procedimiento

private m_condvar notEmpty = new m_condvar("notEmpty");
public
void
deposit
(String
data
){
    op void m_return_from_wait();
    P(m_mutex);

// BoundedBuffer.m, line 13:         while(count == N){

while
(count
==N
){
// BoundedBuffer.m, line 14:             _wait(notFull);

{  m_condvar m_cv = (notFull );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
  P(m_mutex);
}
// BoundedBuffer.m, line 15:         }


// BoundedBuffer.m, line 16: 


// BoundedBuffer.m, line 17:         buffer[rear] = data;

}buffer
[rear
]=data
;
// BoundedBuffer.m, line 18:         rear = (rear + 1) % N;

rear
=(rear
+1)%N
;
// BoundedBuffer.m, line 19:         count++;

count
++;
// BoundedBuffer.m, line 20: 


// BoundedBuffer.m, line 21:         _signal(notEmpty);

(notEmpty ).m_signal();

// BoundedBuffer.m, line 22:     }


// BoundedBuffer.m, line 23: 


// BoundedBuffer.m, line 24:     _proc String fetch(){

  m_next();
}
public
String
fetch
(){
    op void m_return_from_wait();
    P(m_mutex);

// BoundedBuffer.m, line 25:         while(count == 0){

while
(count
==0){
// BoundedBuffer.m, line 26:             _wait(notEmpty);

{  m_condvar m_cv = (notEmpty );
  send m_cv.m_wait(m_return_from_wait,0);
  send m_cv.m_wait_ranks(0);
  m_next();
  P(m_return_from_wait);
  P(m_mutex);
}
// BoundedBuffer.m, line 27:         }


// BoundedBuffer.m, line 28: 


// BoundedBuffer.m, line 29:         String result = buffer[front];

}String
result
=buffer
[front
];
// BoundedBuffer.m, line 30:         front = (front + 1) % N;

front
=(front
+1)%N
;
// BoundedBuffer.m, line 31:         count--;

count
--;
// BoundedBuffer.m, line 32: 


// BoundedBuffer.m, line 33:         _signal(notFull);

(notFull ).m_signal();

// BoundedBuffer.m, line 34: 


// BoundedBuffer.m, line 35:         _return result;

{ if (true) {
  m_next();
  return 
result

// BoundedBuffer.m, line 36:      }

;
}}

// BoundedBuffer.m, line 37: }

  m_next();
throw new RuntimeException("reached end of non-void _proc (BoundedBuffer.m, line 37) without executing a return");
}

// BoundedBuffer.m, line 38: 


// BoundedBuffer.m, line 39: /*


// BoundedBuffer.m, line 40: Este es el codigo para compilar un monitor que luego se utiliza 


// BoundedBuffer.m, line 41: en un programa .jr.


// BoundedBuffer.m, line 42: La manera en que se compila este monitor es la siguiente 


// BoundedBuffer.m, line 43:     m2jr  MonitorTest.m //monitor MESA Lampson y Redell


// BoundedBuffer.m, line 44:     m2jr -sw  MonitorTest.m //monitor Hoare 


// BoundedBuffer.m, line 45: 


// BoundedBuffer.m, line 46: Signal & Continue (SC): The process who signal keep the mutual exclusion and the signaled will 


// BoundedBuffer.m, line 47: be awaken but need to acquire the mutual exclusion before going.


// BoundedBuffer.m, line 48: Signal & Wait (SW): The signaler is blocked and must wait for mutual exclusion to continue 


// BoundedBuffer.m, line 49: and the signaled thread is directly awaken and can start continue its operations.


// BoundedBuffer.m, line 50: Signal & Urgent Wait (SU): Like SW but the signaler thread has the guarantee than it would go 


// BoundedBuffer.m, line 51: just after the signaled thread


// BoundedBuffer.m, line 52: Signal & Exit (SX): The signaler exits from the method directly after the signal and the signaled 


// BoundedBuffer.m, line 53: thread can start directly. This philosophy is not often used.


// BoundedBuffer.m, line 54: 


// BoundedBuffer.m, line 55: Para compilar y hacer un Singal and exit es de esta manera


// BoundedBuffer.m, line 56:     m2jr -sx MonitorTest.m


// BoundedBuffer.m, line 57: */
}
